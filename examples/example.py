# The following was generated by ChatGPT4o from the original example.ts with some trial and error.
# It was manually inspected and tested.

import json
import sys
import uuid
import requests
import hashlib
from base64 import b64encode, b64decode, urlsafe_b64decode, urlsafe_b64encode
from datetime import datetime
import os
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

BASE_URL = 'https://unforget.computing-den.com'

class Note:
    def __init__(self, id, text, creation_date, modification_date, not_deleted, not_archived, pinned, order):
        self.id = id
        self.text = text
        self.creation_date = creation_date
        self.modification_date = modification_date
        self.not_deleted = not_deleted
        self.not_archived = not_archived
        self.pinned = pinned
        self.order = order

class EncryptedNote:
    def __init__(self, id, modification_date, encrypted_base64, iv):
        self.id = id
        self.modification_date = modification_date
        self.encrypted_base64 = encrypted_base64
        self.iv = iv

class LoginData:
    def __init__(self, username, password_client_hash):
        self.username = username
        self.password_client_hash = password_client_hash

class SignupData(LoginData):
    def __init__(self, username, password_client_hash, encryption_salt):
        super().__init__(username, password_client_hash)
        self.encryption_salt = encryption_salt

class LoginResponse:
    def __init__(self, username, token, encryption_salt):
        self.username = username
        self.token = token
        self.encryption_salt = encryption_salt

class Credentials(LoginResponse):
    def __init__(self, username, token, encryption_salt, jwk):
        super().__init__(username, token, encryption_salt)
        self.jwk = jwk

def main():
    if len(sys.argv) < 2:
        usage_and_exit()

    command = sys.argv[1]

    if command == 'signup':
        if len(sys.argv) != 4:
            usage_and_exit()
        username = sys.argv[2]
        password = sys.argv[3]
        signup(username, password)
    elif command == 'login':
        if len(sys.argv) != 4:
            usage_and_exit()
        username = sys.argv[2]
        password = sys.argv[3]
        login(username, password)
    elif command == 'post':
        if len(sys.argv) != 3:
            usage_and_exit()
        text = sys.argv[2]
        post_note(text)
    elif command == 'get':
        id = sys.argv[2] if len(sys.argv) == 3 else None
        get_note(id)
    else:
        usage_and_exit()
    print('Success.')

def usage_and_exit():
    print("""
Usage: python3 script.py COMMAND
Available commands:
  signup USERNAME PASSWORD
  login USERNAME PASSWORD
  post TEXT
  get [ID]
""")
    sys.exit(1)

def signup(username, password):
    # Generate a random salt for encryption key derivation
    salt = bytes_to_hex_string(os.urandom(16))
    # Calculate password hash
    hash = calc_password_hash(username, password)
    # Prepare signup data
    data = SignupData(username, hash, salt)
    # Send signup request and handle response
    res_dict = post('/api/signup', data.__dict__)
    res = LoginResponse(res_dict['username'], res_dict['token'], res_dict['encryption_salt'])
    # Create credentials including derived encryption key
    credentials = create_credentials(res, password)
    # Save credentials to file
    write_credentials(credentials)

def login(username, password):
    # Calculate password hash
    hash = calc_password_hash(username, password)
    # Prepare login data
    data = LoginData(username, hash)
    # Send login request and handle response
    res_dict = post('/api/login', data.__dict__)
    res = LoginResponse(res_dict['username'], res_dict['token'], res_dict['encryption_salt'])
    # Create credentials including derived encryption key
    credentials = create_credentials(res, password)
    # Save credentials to file
    write_credentials(credentials)

def post_note(text):
    # Create a new note
    note = Note(
        str(uuid.uuid4()),
        text,
        datetime.utcnow().isoformat(),
        datetime.utcnow().isoformat(),
        1, 1, 0,
        int(datetime.utcnow().timestamp() * 1000)
    )
    # Read credentials from file
    credentials = read_credentials()
    # Import the encryption key from credentials
    key = import_key(credentials)
    # Encrypt the note
    encrypted_note = encrypt_note(note, key)
    # Send the encrypted note to the server
    post('/api/add-notes', {'notes': [encrypted_note.__dict__]}, credentials)
    print(f'Posted note with ID {note.id}')

def get_note(id):
    # Read credentials from file
    credentials = read_credentials()
    # Import the encryption key from credentials
    key = import_key(credentials)
    # Prepare list of note IDs to retrieve (or None to get all)
    ids = [id] if id else None
    # Retrieve encrypted notes from the server
    encrypted_notes = post('/api/get-notes', {'ids': ids}, credentials)
    if not encrypted_notes:
        print('Not found')
    else:
        # Decrypt the received notes
        notes = [decrypt_note(EncryptedNote(**note), key) for note in encrypted_notes]
        # Print the decrypted notes
        for note in notes:
            print(json.dumps(note.__dict__, indent=2) + '\n')

def encrypt_note(note, key):
    # Convert the note to bytes
    data = json.dumps(note.__dict__).encode()
    # Generate a random initialization vector (IV)
    iv = os.urandom(12)
    # Create an encryptor with AES-GCM mode
    encryptor = Cipher(algorithms.AES(key), modes.GCM(iv), backend=default_backend()).encryptor()
    # Encrypt the note data
    encrypted = encryptor.update(data) + encryptor.finalize()
    # Combine the encrypted data and tag, then encode in base64
    encrypted_base64 = b64encode(encrypted + encryptor.tag).decode('utf-8')
    # Return an EncryptedNote object
    return EncryptedNote(note.id, note.modification_date, encrypted_base64, bytes_to_hex_string(iv))

def decrypt_note(encrypted_note, key):
    # Decode the base64-encoded encrypted data
    encrypted_bytes_with_tag = b64decode(encrypted_note.encrypted_base64)
    # Extract the IV and tag from the encrypted data
    iv = hex_string_to_bytes(encrypted_note.iv)
    encrypted_bytes, tag = encrypted_bytes_with_tag[:-16], encrypted_bytes_with_tag[-16:]
    # Create a decryptor with AES-GCM mode
    decryptor = Cipher(algorithms.AES(key), modes.GCM(iv, tag), backend=default_backend()).decryptor()
    # Decrypt the note data
    decrypted_bytes = decryptor.update(encrypted_bytes) + decryptor.finalize()
    # Convert the decrypted bytes back to a string and parse as JSON
    note_string = decrypted_bytes.decode('utf-8')
    return Note(**json.loads(note_string))

def read_credentials():
    # Read and parse the credentials from a file
    with open('credentials.json', 'r') as file:
        return Credentials(**json.load(file))

def write_credentials(credentials):
    # Write the credentials to a file
    with open('credentials.json', 'w') as file:
        json.dump(credentials.__dict__, file, indent=2)
    print('Wrote credentials to ./credentials.json')

def import_key(credentials):
    # Decode the base64-encoded key from the credentials
    key = urlsafe_b64decode(credentials.jwk['k'] + '==')
    return key

def create_credentials(res, password):
    # Derive a PBKDF2 key from the password and the encryption salt
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=bytes.fromhex(res.encryption_salt),
        iterations=100000,
        backend=default_backend()
    )
    key = kdf.derive(password.encode())
    # Create a JSON Web Key (JWK) from the derived key
    jwk = {'key_ops': ['encrypt', 'decrypt'], 'ext': True, 'kty': 'oct', 'k': urlsafe_b64encode(key).decode('utf-8').rstrip('=')}
    # Return credentials including the JWK
    return Credentials(res.username, res.token, res.encryption_salt, jwk)

def post(pathname, body, credentials=None):
    # Construct the full URL with the optional token as a query parameter
    url = f'{BASE_URL}{pathname}'
    if credentials:
        url += f'?token={credentials.token}'
    # Send a POST request with the provided body
    headers = {'Content-Type': 'application/json'}
    response = requests.post(url, headers=headers, json=body)
    response.raise_for_status()
    return response.json()

def calc_password_hash(username, password):
    # Calculate a SHA-256 hash of the username, password, and a static random number
    text = f'{username}{password}32261572990560219427182644435912532'
    hash_buf = hashlib.sha256(text.encode()).digest()
    return bytes_to_hex_string(hash_buf)

def bytes_to_hex_string(bytes):
    # Convert a byte array to a hex string
    return ''.join(f'{byte:02x}' for byte in bytes)

def hex_string_to_bytes(hex_string):
    # Convert a hex string to a byte array
    if len(hex_string) % 2 != 0:
        raise ValueError('Invalid hex string')
    return bytes.fromhex(hex_string)

if __name__ == "__main__":
    main()
